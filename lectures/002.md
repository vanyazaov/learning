## Учебный проект: [Deworker.pro](https://deworker.pro/edu/series/ip-geolocator)
### "Пошаговая разработка гибкого компонента IP-локатора. Пример декомпозиции сложного объекта. Практическое применение паттернов проектирования".

### 2. Ответственности и зависимости

В этом эпизоде мы рассмотрем распределение ответственности и какие могут быть зависимости, как их выносить и использовать.

Как мы можем заметить, в нашем методе locate() есть функция, которая обращается к внешнему ресурсу:
```php
public function locate(Ip $ip): ?Location
{
    // ...
    $response = file_get_contents($url);
    // ...
}
```
При этом данная функция может вернуть ошибку или не сможет подключиться и вернет false.
Чтобы отловить ошибку с данной функцей, приходилось делать так:
```php
$response = @file_get_contents($url);
if ($response === false) {
    throw new \RuntimeException(error_get_last());
}
```
~~~ 
Сохранение в Git: Обработка ошибок API
~~~
Также мы можем в дальнейшем проверять статус ответа и если вернулся не 200, то кидать ошибку.
Соответственно, чем более продвинутый код мы здесь пишем, тем больше строчек появляется и вписывать их сюда не совсем уместо,
потому что метод locate() разрастется до колосальных размеров.

Что мы можем сделать?

Например, вынести код в отдельный приватный метод, в который передавать Url.
~~~ 
Сохранение в Git: Вынесение в метод
~~~
В принципе так можно поступить, но в этом случае возникает небольшая проблема.
Если у нас будут несколько локаторов, которые будут работать с разными сервисами,
то им понадобится один и тот же метод get().

Как можно поступить?

Можно наследовать все локаторы от одного базового класса и метод
get() поместить в базовый класс и сделать его protected.

Но мы можем модифицировать код и всю ответственность за лазанье 
в Интернет переместить в отдельный класс HttpClient:
```php
class HttpClient
{
    public function get(string $url): ?string
    {
        $response = @file_get_contents($url);
        if ($response === false) {
            throw new \RuntimeException(error_get_last()['message']);
        }
        return $response;
    }
}
```
И теперь этот клиент мы можем использовать у себя.
Так как метод get() у нас не статический, нам нужно
как-то передать объект этого клиента в локатор.
Мы можем добавить в локатор конструктор и передовать клиента туда:
```php
private $client;

public function __construct(HttpClient $client)
{
    $this->client = $client;
}

public function locate(Ip $ip): ?Location
{
    // ...
    $response = $this->client->get($url);
    $data = json_decode($response, true);
    // ...
}
```
Теперь, если у нас будут несколько локаторов, то им всем мы можем передать один и тот же объект клиента.
Это экономит нам время и позволяет избежать ошибок.
И такой клиент мы можем использовать не только для локатора, но и для 
других компонентов, которые могут быть на нашем сайте.
~~~ 
Сохранение в Git: Вынесение кода в класс
~~~
Вынесение кода в отдельный класс нам ещё поможет в тестах,
так как мы можем подменять этот класс на какую-нибудь заглушку.

Сейчас тесты для локатора у нас являются интеграционными, 
потому что они обращаются к внешнему ресурсу.
```php
class LocatorTest extends TestCase
{
    public function testSuccess(): void
    {
        $client = new HttpClient();

        $locator = new Locator($client);
        $location = $locator->locate(new Ip('8.8.8.8'));

        self::assertNotNull($location);
        self::assertEquals('United States', $location->getCountry());
        self::assertEquals('Louisiana', $location->getRegion());
        self::assertEquals('Monroe', $location->getCity());
    }
//...
```
Но теперь, при помощи createMock() мы можем создать заглушку
и он на лету в памяти создаст класс, который наследуется от HttpClient
и у которого будут переопределены те методы, которые находятся в клиенте.
И мы можем настроить его, указав, что должно возвращаться:
```php
$client = $this->createMock(HttpClient::class);

$client->method('get')->willReturn(json_encode([
    'country_name' => 'United States',
    'state_prov' => 'Louisiana',
    'city' => 'Monroe'
]));

$locator = new Locator($client);
$location = $locator->locate(new Ip('8.8.8.8'));
```
Теперь этот тест является чистым Unit-тестом, который не лазит в интернет и
проверяет только внутреннюю логику локатора.
Здесь есть потенциальная проблема, что сервис может переименовать свои поля, но
такие случаи уже должны ловиться интеграционными тестами, которые будут проверять контроллер.
~~~ 
Сохранение в Git: Моки и стабы в тестах
~~~
Мы также можем вынести ключ API в конструктор:
```php
private $client;
private $apiKey;

public function __construct(HttpClient $client, string $apiKey)
{
    $this->client = $client;
    $this->apiKey = $apiKey;
}
```
В следующем эпизоде мы рассмотрим как использовать в коде несколько провайдеров.
~~~ 
Сохранение в Git: Конфигурирование ключа API
~~~
