## Учебный проект: [Deworker.pro](https://deworker.pro/edu/series/ip-geolocator)
### "Пошаговая разработка гибкого компонента IP-локатора. Пример декомпозиции сложного объекта. Практическое применение паттернов проектирования".

### 2. Ответственности и зависимости

В этом эпизоде мы рассмотрем распределение ответственности и какие могут быть зависимости, как их выносить и использовать.

Как мы можем заметить, в нашем методе locate() есть функция, которая обращается к внешнему ресурсу:
```php
public function locate(Ip $ip): ?Location
{
    // ...
    $response = file_get_contents($url);
    // ...
}
```
При этом данная функция может вернуть ошибку или не сможет подключиться и вернет false.
Чтобы отловить ошибку с данной функцей, приходилось делать так:
```php
$response = @file_get_contents($url);
if ($response === false) {
    throw new \RuntimeException(error_get_last());
}
```
~~~ 
Сохранение в Git: Обработка ошибок API
~~~
Также мы можем в дальнейшем проверять статус ответа и если вернулся не 200, то кидать ошибку.
Соответственно, чем более продвинутый код мы здесь пишем, тем больше строчек появляется и вписывать их сюда не совсем уместо,
потому что метод locate() разрастется до колосальных размеров.

Что мы можем сделать?

Например, вынести код в отдельный приватный метод, в который передавать Url.
~~~ 
Сохранение в Git: Вынесение в метод
~~~
В принципе так можно поступить, но в этом случае возникает небольшая проблема.
Если у нас будут несколько локаторов, которые будут работать с разными сервисами,
то им понадобится один и тот же метод get().

Как можно поступить?

Можно наследовать все локаторы от одного базового класса и метод
get() поместить в базовый класс и сделать его protected.

Но мы можем модифицировать код и всю ответственность за лазанье 
в Интернет переместить в отдельный класс HttpClient:
```php
class HttpClient
{
    public function get(string $url): ?string
    {
        $response = @file_get_contents($url);
        if ($response === false) {
            throw new \RuntimeException(error_get_last()['message']);
        }
        return $response;
    }
}
```
И теперь этот клиент мы можем использовать у себя.
Так как метод get() у нас не статический, нам нужно
как-то передать объект этого клиента в локатор.
Мы можем добавить в локатор конструктор и передовать клиента туда:
```php
private $client;

public function __construct(HttpClient $client)
{
    $this->client = $client;
}

public function locate(Ip $ip): ?Location
{
    // ...
    $response = $this->client->get($url);
    $data = json_decode($response, true);
    // ...
}
```
Теперь, если у нас будут несколько локаторов, то им всем мы можем передать один и тот же объект клиента.
Это экономит нам время и позволяет избежать ошибок.
И такой клиент мы можем использовать не только для локатора, но и для 
других компонентов, которые могут быть на нашем сайте.
~~~ 
Сохранение в Git: Вынесение кода в класс
~~~

