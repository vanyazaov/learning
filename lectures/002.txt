Лекция "Сервер и структура проекта": https://deworker.pro/edu/series/http-framework/project-structure

Мы будем писать как сам фреймворк, так и код демонстрационного приложения, которое будет использовать этот фреймворк.

Весь код мы будем писать на PHP и для этого использовать классическую связку NGINX+PHP-FPM.

Чтобы проверить работу сервера NGINX нам необходима тестовая страница.
Доступные снаружи ресурсы мы будем размещать в папке /public/ в которой создадим файл index.html

---- сохранение в git ---- Демонстрационная HTML-страница

Для настройки табуляции в PHPStorm необходимо перейти в меню File/Settings/Editor/Code Style
и открыть раздел HTML и там настроить табы и кол-во пробелов на замену таба.
Если вы разрабатываете на каком-нибудь FRONTEND-фреймворке, то там принято использовать 2 пробела вместо 4х.
Но настраивать вручную это не всегда удобно.
Если же в команде разные программисты используют несколько IDE-редакторов, то было бы неплохо иметь некий
конфигурационный файл, который бы понимали все редакторы и настраивали среду программирования автоматически.
И такой файл есть. Необходимо в проекте создать файл ".editorconfig" и в нем определить настройки.
Доступные настройки можно посмотреть на сайте editorconfig.org

---- сохранение в git ---- Настройка табуляции с editorconfig

Установка связки NGINX+PHP-FPM
Здесь можно поступить 2мя способами: настроить все вручную или систему виртуализации.
---Недостатки ручной установки
Ручной способ не позволяет разным программистам настроить у себя одинаковую среду разработки, так как могут быть
допущены ошибки, ОС могут быть разными и т.д.
---Использование виртуализации
Виртуализация может быть либо с использованием полноценных виртуальных машин или с использованием легковесных
контейнеров.

Если выбирать путь с использованием виртуальных машин, то мы можем установить на свой компьютер одну из систем
виртуализации, например VirtualBox. Для того, чтобы автоматизировать процесс создания и настройки виртуальной машины мы
можем установить утилиту Vagrant.
Для этого создается конфигурационный файл Vagrantfile в котором описывается какая ОС и какой софт должен быть
установлен.
После чего будет достаточно выполнить команду vagrant up, чтобы все установилось и настроилось автоматически.
---Использование контейнеров
Вместо того, чтобы использовать полноценные виртуальные машины с ОС в последнее время набрал популярность способ с
использованием контейнеров.

Одной из систем контейнеризации является Docker
---Запуск процессов через Docker
В докере можно использовать готовые образы, которые находятся на hub.docker.com
docker run nginx:1.21-alpine nginx

По-умолчанию nginx запускается в качестве демона, но для просмотра этот режим мы можем отключить:
docker run nginx:1.21-alpine nginx -g 'daemon off;'
После этого процесс будет запущен со случайным IP-адресом, узнав который мы можем открыть по нему сайт.
Но это неудобно, нам бы хотелось использовать привычный домен localhost, для этого мы можем пробросить порты:
docker run -p "80:80" nginx:1.21-alpine nginx -g 'daemon off;'
Докер по умолчанию запускается только с тем окружением, которое имеется в образе, а нам бы хотелось использовать свои
файлы. Для этого мы можем подключить виртуальный том, указав, что мы хотим поместить текущую директорию в папку app
докера. Для запуска из консоли необходимо указывать полный путь до подключаемой папки, вместо этого можно
воспользоваться переменной окружения $PWD.
docker run -p "80:80" nginx:1.21-alpine -v "{$PWD}:/app" nginx -g 'daemon off;'
Но это работать не будет так как nginx не настроен на использование нашей папки app. Мы можем пробросить свой
конфигурационный файл через volume или создать свой образ в котором перезаписать конфигурацию сервера.
---Создание своего образа
Если мы хотим создать свой собственный образ, то для содержания всех конфигурационных файлов мы можем создать папку,
например docker.
В ней определить папку nginx, в которой разместить файл Dockerfile в котором описать создание нашего собственного
образа.
В нём указать, что мы берем все файлы из оригинального образа nginx:1.21-alpine
FROM nginx:1.21-alpine
Если мы работаем с NGINX, то у него имеется папка conf.d куда мы можем прокидывать собственные файлы конфигурации.
И мы у себя можем создать такую же папку conf.d и поместить в ней наш файл конфигурации,например default.conf
Теперь, когда мы сделали такую папку и написали свой конфиг, мы можем её скопировать в оригинальное место образа:
COPY ./conf.d /etc/nginx/conf.d
По-умолчанию все команды внутри контейнера работают с корневой директорией / и если мы хотим, чтобы все команды уже
выполнялись из нашей прокинутой папки, то необходимо определить рабочую директорию:
WORKDIR /app

---- сохранение в git ---- Создание своего образа
---Работа с Docker Compose

Чтобы не заниматься вручную запуском различных образов и организации между ними сети удобно использовать отдельную
утилиту под названием Docker Compose.
После установки можно создать файл настроек docker-compose.yml и описать какие сервисы у нас будут.
Сначала мы пишем с какой версией собираемся работать
version: "3.9"
и далее описываем сервисы:
services:
и первым делом говорим, что нам нужен сервис nginx, который мы будем собирать по докерфайлу, который находится в нашей
папке:
services:
  nginx:
    build:
      context: docker/nginx
Также необходимо указать, что нам необходимо прокидывать порт и рабочую папку:
      ports:
        - "80:80"
      volumes:
        - ./:/app
Теперь мы можем создать наши сервисы командой, ключ --pull скачает свежие версии образов, если они есть:
docker-compose build --pull
Теперь мы можем запустить наши сервисы, флаг -d запускает все процессы в фоне:
docker-compose up -d
Готово. Теперь в браузере по адресу localhost будет отображаться страница с нашими данными, которые мы можем менять в
реальном времени.

---- сохранение в git ---- Работа с Docker Compose
---Установка PHP-FPM

Для того, чтобы мы могли работать с PHP-файлами необходимо установить php-fpm и настроить сервер NGINX на проксирование
запросов.
Создадим отдельную папку docker/php-fpm и поместим там Dockerfile.
В нем мы основываемся на образе php:8.1-fpm-alpine
FROM php:8.1-fpm-alpine
Для удобства переименовываем файл php.ini-development в php.ini
RUN mv $PHP_INI_DIR/php.ini-development $PHP_INI_DIR/php.ini
и устанавливаем рабочую директорию
WORKDIR /app

Теперь нам необходимо описать этот сервис в docker-compose:
php-fpm:
    build:
        context: docker/php-fpm
    volumes:
        -   ./:/app

Теперь необходимо настроить NGINX, чтобы динамические запросы автоматически проксировались на наш php-fpm:
Отлавливаем все запросы, которые приходят к нам на сервер и переадрисовываем их на файл index.php
    location / {
      try_files $uri /index.php?$args;
    }
Если запускется файл php, то запрос передаем созданному сервису php-fpm:9000
    location ~ \.php$ {
      fastcgi_pass php-fpm:9000;
      fastcgi_index index.php;
      include fastcgi_params;
      fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
      fastcgi_param SCRIPT_NAME $fastcgi_script_name;
      fastcgi_param PATH_INFO $fastcgi_path_info;
    }

Мы должны быть уверены, что этот сервис запущен до запуска веб-сервера. Для этого мы можем прописать очередь запуска в
файле docker-compose:
nginx:
  depends_on:
      -   php-fpm

Осталось пересобрать наши образы и перезапустить проект:
docker-compose down
docker-compose build --pull
docker-compose up -d

---- сохранение в git ---- Установка PHP-FPM
---Упрощение запуска в терминале

Чтобы не запускать постоянно эти длинные команды и не слидить за их последовательностью, можно использовать отдельную
утилиту make и создать отдельный файл под названием Makefile.
В нем можно прописать все команды в нужной последовательности объявив как отдельные команды, так и каскадные:
init: docker-down-clear docker-pull docker-build-pull docker-up
down: docker-down-clear

docker-up:
	docker-compose up -d

docker-down-clear:
	docker-compose down -v --remove-orphans

docker-pull:
	docker-compose pull

docker-build-pull:
	docker-compose build --pull

Теперь мы можем выполнить короткую команду make init

---- сохранение в git ---- Упрощение запуска в терминале

Помимо запуска скриптов в веб-сервере, нам потребуется запуск и в консоли, например Composer.
Для этих целей мы можем дополнительно установить PHP-CLI.
Особенность PHP-FPM в том, что при его установки автоматически устанавливается и PHP-CLI.
Поэтому в уже запущенном контейнере мы можем запустить консольную команду через exec:
docker-compose exec php-fpm php -v

Но философия контейнеризации отличается от философии виртуальных машин.
Если мы используем виртуальную машину, то там устанавливаем весь софт, который нам потребуется.
В контейнерах же мы запускаем отдельные процессы.
Соответственно если нам нужен отдельный процесс, то мы можем объявить отдельный сервис в docker-compose и назвать его
php-cli и он будет собираться из другой нашей папки:
    php-cli:
        build:
            context: docker/php-cli
        volumes:
            -   ./:/app
и Dockerfile содержать будет только консольный PHP:
FROM php:8.1-cli-alpine

В отличие от работающего контейнера php-fpm команды для php-cli необходимо запускать через run вместо exec, так как
сервис запускается отрабатывает и сразу останавливается. Если мы не хотим мусорить в нашей системе, то можем передавать
флаг --rm, которые после отработки удалит все, что связано с этим контейнером:
docker-compose run --rm php-cli php -v

---- сохранение в git ---- Консольный процесс PHP-CLI
---Переопределение пользователя
Стоит учитывать, что докер-процессы могут запускаться под разными пользователями.
Так в образе php-fpm существует пользователь www-data и наш скрипт запуститься от этого пользователя.
Но в образе php-cli нет пользователей и в этом случае все команды запускаются от root.
Чтобы повысить безопасность нашего контейнера мы можем создать своего пользователя с идентификатором 1000:
RUN addgroup -g 1000 app && adduser -u 1000 -G app -s /bin/sh -D app
Это полезно тем, что первый пользователь после root создается с идентификатором 1000. Таким образом, те файлы, которые
создаются на моей машине будет иметь такой же идентификатор, что и контейнере докера, соответственно проблем с правами
доступа на созданные файлы через контейнер не будет.
После создания такого пользователя мы можем на него переключится:
USER app

---- сохранение в git ---- Переопределение пользователя
---Установка Composer

Установить composer можнодвумя способами либо написать команду для его установки либо скопировать из готового образа на
docker-hub.
Если хотим использовать второй вариант, то можем написать такую команду:
COPY --from=composer:2 /usr/bin/composer /usr/local/bin/composer
После перебилда мы можем проверить наличие композера:
docker-compose run --rm php-cli composer --version

---- сохранение в git ---- Установка Composer
---Инициализация проекта

Для создания конфигурационного файла выполним команду
docker-compose run --rm php-cli composer init
Он спросит как назвать проект, например так:
vankazaov/demo-php-http-framework
Далее спросит какое-нибудь описание
Source code for our workshop
Автора можно не указовать.
Затем указать, что это проект.
Далее указываем лицензию: BSD-3-Clause
Укажем зависимость от php

Витоге будут созданы файлы composer.json, composer.lock, .gitignore и папка vendor с установленными зависимостями.
{
    "name": "vankazaov/demo-php-http-framework",
    "description": "Source code for our workshop",
    "type": "project",
    "license": "BSD-3-Clause",
    "authors": [
        {
            "name": "deworker.pro"
        }
    ],
    "require": {
      "php": "^8.1"
    }
}

Мы также можем дополнить файл Makefile:
composer-install:
  docker-compose run --rm php-cli composer install

Также мы можем настроить в composer.json сортировку зависимостей:
    "config": {
      "sort-packages": true
    }

---- сохранение в git ---- Инициализация проекта
---Структура исходного кода, Автозагрузка классов проекта

Наш код мы будем хранить в папке /src.
Так как мы создаем фреймворк и демо-приложение на нем, то создадим две папки внутри: App и Framework.
Теперь в файле composer.json необходимо настроить атозагрузку классов:
    "autoload": {
      "psr-4": {
        "App\\": "src/App",
        "Framework\\": "src/Framework"
      }
    }
И выполнить команду docker-compose run --rm php-cli composer dump-autoload
Также можем создать папку tests и внутри такие же папки App и Framework.
Для тестов нужно будет прописать в composer.json секцию autoload-dev:
    "autoload-dev": {
      "psr-4": {
        "Test\\App\\": "tests/App",
        "Test\\Framework\\": "tests/Framework"
      }
    }

---- сохранение в git ---- Структура исходного кода
---Подключение PHPUnit

docker-compose run --rm php-cli composer require --dev phpunit/phpunit
Теперь запустить тесты можно через папку vendor:
docker-compose run --rm php-cli ./vendor/bin/phpunit
У нас ещё нет конфигурации и её мы можем автоматически создать запустив phpunit с соответствующим флагом:
docker-compose run --rm php-cli ./vendor/bin/phpunit --generate-configuration
1. Укажем, где храниться скрипт автозагрузки (по-умолчанию).
2. Какую папку использовать для тестов (по-умолчанию).
3. Какую папку использовать для исходников (по-умолчанию).
4. Какую папку использовать для кеша. Здесь переопределим, создадим папку var, поместим в ней файл .gitignore/
Укажем путь var/phpunit.cache
В результате будет создан файл phpunit.xml.
Изменим расположение схемы с внешнего ресурса на внутренний:
xsi:noNamespaceSchemaLocation="vendor/phpunit/phpunit/phpunit.xsd"
Также уберем секцию <coverage>

Теперь мы можем запускать тесты: docker-compose run --rm php-cli ./vendor/bin/phpunit

---- сохранение в git ---- Подключение PHPUnit
---Подключение автозагрузчика, Пробный класс и тест

Для этого в нашем индексном файле нужно прописать:
require __DIR__ . '../vendor/autoload.php';

Чтобы проверить автозагрузку и тесты создадим пробный класс и тест Example.
После запуска теста мы увидим, что тест пометился как R з-за того, что у нас используются настройки покрытия тестов.
Их необходимо удалить из конфигурации и запустить тест ещё раз.
         -- forceCoversAnnotation="true"
         -- beStrictAboutCoversAnnotation="true"
Длязапуска тестов в цветном режиме, необходимо передать соответствующий параметр:
docker-compose run --rm php-cli ./vendor/bin/phpunit --colors=always
Чтобы каждый раз не писать длинную команду, мы можем её упростить.
Для этого в файле composer.json создадим секцию scripts и пропишем эту команду там:
    "scripts": {
      "test": "phpunit --colors=always"
    }
Теперь мы можем запускать тесты через composer:
docker-compose run --rm php-cli composer test

Теперь эту команду мы можем поместить в наш Makefile:
test:
  docker-compose run --rm php-cli composer test
и запускать теперь так: make test

---- сохранение в git ---- Подключение автозагрузчика, Пробный класс и тест
