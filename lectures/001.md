## Учебный проект: [Deworker.pro](https://deworker.pro/edu/series/ip-geolocator)
### "Пошаговая разработка гибкого компонента IP-локатора. Пример декомпозиции сложного объекта. Практическое применение паттернов проектирования".

~~~ 
Сохранение в Git: Инициализация проекта
~~~

### 1. Анализ требований и пробная версия

При помощи разрабатываемого компонента, зная IP пользователя мы сможем определить его страну, регион и город в котором он находится.

Что он из себя может представлять?

Это может быть некий класс Locator с методом locate в который мы передаем IP-адрес пользователя:
```php
$locator = new Locator();
$location = $locator->locate($ip);
```
Например, этот метод может вернуть некий массив содержащий название страны, региона и города.

И чтобы проверить правильность работы создаваемого класса, мы можжем написать некий тест, в котором мы будет передавать IP-адрес и проверять, что вернувшийся результат не пустой:

```php
use PHPUnit\Framework\TestCase;

class LocatorTest extends TestCase
{
    public function testSuccess(): void
    {
        $locator = new Locator();
        $location = $locator->locate('8.8.8.8');
        
        self::assertNotNull($location);
    }
}
```
Другой тест будет проверять ситуацию, что будет, если по IP-адресу ничего не нашлось:
```php
public function testNotFound(): void
{
    $locator = new Locator();
    $location = $locator->locate('127.0.0.1');

    self::assertNull($location);
}
```
И третий вариант, который мы можем протестировать. Что будет, если мы передадим какой-нибудь неверный адрес. Реально работающий код в этом случае должен вернуть исключение:
```php
public function testInvalid(): void
{
    $locator = new Locator();

    $this->expectException(InvalidArgumentException::class);
    $location = $locator->locate('invalid');
}
```
Можем ещё добавить один метод, который будет проверять, что этот адрес пустой:
```php
public function testEmpty(): void
{
    $locator = new Locator();

    $this->expectException(InvalidArgumentException::class);
    $location = $locator->locate('');
}
```
И когда мы написали такие тесты, мы можем уточнить тест для метода testSuccess():
```php
public function testSuccess(): void
{
    $locator = new Locator();
    $location = $locator->locate('8.8.8.8');

    self::assertNotNull($location);
    self::assertEquals('United States', $location['country']);
    self::assertEquals('California', $location['region']);
    self::assertEquals('Mountain View', $location['city']);
}
```
Но с массивом не очень удобно работать, так как мы не знаем какие поля оттуда вернуться, какие поля там есть, у нас не работает автоподстановка в редакторе и нет никаких проверок.
В этом случае удобно работать с объектом:
```php
public function testSuccess(): void
{
    $locator = new Locator();
    $location = $locator->locate('8.8.8.8');

    self::assertNotNull($location);
    self::assertEquals('United States', $location->getCountry());
    self::assertEquals('California', $location->getRegion());
    self::assertEquals('Mountain View', $location->getCity());
}
```
~~~ 
Сохранение в Git:  Внешний вид и тесты
~~~
В примитивном виде, что из себя должен представлять Location?
Это может быть некая структура, содержащая нужные нам поля и которую мы можем заполнить через конструктор.
```php
class Location
{
    private $country;
    private $region;
    private $city;

    public function __construct(
        string $country,
        ?string $region,
        ?string $city) {
        $this->country = $country;
        $this->region = $region;
        $this->city = $city;
    }

    public function getCountry(): string {
        return $this->country;
    }

    public function getRegion(): ?string {
        return $this->region;
    }

    public function getCity(): ?string {
        return $this->city;
    }
}
```
~~~ 
Сохранение в Git:  Структура Location
~~~
Теперь нам нужно написать класс Locator. Из написанного теста нам понятна структура, которая должна быть:
```php
class Locator
{
    public function locate(string $ip): ?Location {}
}
```
В первоначальном виде мы напишим его в примитивном виде, чтобы он как-то работал.
Чтобы проверить правильность присланного IP мы можем при помощи условий IF:
```php
public function locate(string $ip): ?Location
{
    if (empty($ip)) {
        throw new InvalidArgumentException('Empty IP.');
    }

    if (filter_var($ip, FILTER_VALIDATE_IP) === false) {
        throw new InvalidArgumentException('Invalid IP ' . $ip);
    }
}
```
~~~ 
Сохранение в Git:  Первая версия локатора
~~~
Если все проверки мы прошли, то нам нужно при помощи сторонних сервисов получить нужные данные.
Например, мы можем воспользоваться платным API: ipgeolocation.io
Чтобы работать с данным сервисом нужно в параметрах запроса передать свой API ключ и IP.
Когда мы сформировали URL, то с любым удобным методом мы можем получить результат:
```php
$url = 'https://api.ipgeolocation.io/ipgeo?' . http_build_query([
        'apiKey' => 'b72326c0a81b...',
        'ip' => $ip
]);

$response = file_get_contents($url);
```
~~~ 
Сохранение в Git:  Запрос в API
~~~
Сервис работает так, что в случае успеха он возвращает JSON.
Нам нужно его распарсить в ассоциативный массив.
Но если сервис что-то не нашел, то он возвращает дефисы и для корректной работы нам нужно отфильтровать эти пустые значения.
Сделаем это при помощи функции array_map и если страна не нашлась, то сразу вернем null:
```php
$response = file_get_contents($url);
$data = json_decode($response, true);

$data = array_map(fn($value) => $value !== '-' ? $value : null, $data);

if (empty($data['country_name'])) {
    return null;
}
```
Если же страна определена, то возвращаем объект Location, заполняя его данными из массива:
```php
return new Location($data['country_name'], $data['state_prov'], $data['city']);
```
~~~
Сохранение в Git:  Обработка ответа из API
~~~
Сейчас мы можем произвести некоторые улучшения в коде.
Посмотрите, у нас имеются проверки IP-адреса и если помимо метода locate() будут и другие методы, то там тоже придется повторять все эти проверки.
Вместо этого, весь код по проверке IP-адреса можно вынести, инкапсулировать в свой тип данных.
```php
class Ip
{
    private $value;

    public function __construct(string $ip)
    {
        if (empty($ip)) {
            throw new \InvalidArgumentException('Empty IP.');
        }

        if (filter_var($ip, FILTER_VALIDATE_IP) === false) {
            throw new \InvalidArgumentException('Invalid IP ' . $ip);
        }
        
        $this->value = $ip;
    }

    public function getValue(): string
    {
        return $this->value;
    }
}
```
Соответственно в классе Locator мы изменим принимаемый тип со string на Ip:
```php
    public function locate(Ip $ip): ?Location
    {

        $url = 'https://api.ipgeolocation.io/ipgeo?' . http_build_query([
                'apiKey' => 'b72326c0a81b487f85804eb84f433b8a',
                'ip' => $ip->getValue()
        ]);
```
~~~
Сохранение в Git:  Инкапсуляция проверок в Value Object
~~~
