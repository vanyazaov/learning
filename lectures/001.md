## Учебный проект: [Deworker.pro](https://deworker.pro/edu/series/ip-geolocator)
### "Пошаговая разработка гибкого компонента IP-локатора. Пример декомпозиции сложного объекта. Практическое применение паттернов проектирования".

~~~ 
Сохранение в Git: Инициализация проекта
~~~

### 1. Анализ требований и пробная версия

При помощи разрабатываемого компонента, зная IP пользователя мы сможем определить его страну, регион и город в котором он находится.

Что он из себя может представлять?

Это может быть некий класс Locator с методом locate в который мы передаем IP-адрес пользователя:
```php
$locator = new Locator();
$location = $locator->locate($ip);
```
Например, этот метод может вернуть некий массив содержащий название страны, региона и города.

И чтобы проверить правильность работы создаваемого класса, мы можжем написать некий тест, в котором мы будет передавать IP-адрес и проверять, что вернувшийся результат не пустой:

```php
use PHPUnit\Framework\TestCase;

class LocatorTest extends TestCase
{
    public function testSuccess(): void
    {
        $locator = new Locator();
        $location = $locator->locate('8.8.8.8');
        
        self::assertNotNull($location);
    }
}
```
Другой тест будет проверять ситуацию, что будет, если по IP-адресу ничего не нашлось:
```php
public function testNotFound(): void
{
    $locator = new Locator();
    $location = $locator->locate('127.0.0.1');

    self::assertNull($location);
}
```
И третий вариант, который мы можем протестировать. Что будет, если мы передадим какой-нибудь неверный адрес. Реально работающий код в этом случае должен вернуть исключение:
```php
public function testInvalid(): void
{
    $locator = new Locator();

    $this->expectException(InvalidArgumentException::class);
    $location = $locator->locate('invalid');
}
```
Можем ещё добавить один метод, который будет проверять, что этот адрес пустой:
```php
public function testEmpty(): void
{
    $locator = new Locator();

    $this->expectException(InvalidArgumentException::class);
    $location = $locator->locate('');
}
```
И когда мы написали такие тесты, мы можем уточнить тест для метода testSuccess():
```php
public function testSuccess(): void
{
    $locator = new Locator();
    $location = $locator->locate('8.8.8.8');

    self::assertNotNull($location);
    self::assertEquals('United States', $location['country']);
    self::assertEquals('California', $location['region']);
    self::assertEquals('Mountain View', $location['city']);
}
```
Но с массивом не очень удобно работать, так как мы не знаем какие поля оттуда вернуться, какие поля там есть, у нас не работает автоподстановка в редакторе и нет никаких проверок.
В этом случае удобно работать с объектом:
```php
public function testSuccess(): void
{
    $locator = new Locator();
    $location = $locator->locate('8.8.8.8');

    self::assertNotNull($location);
    self::assertEquals('United States', $location->getCountry());
    self::assertEquals('California', $location->getRegion());
    self::assertEquals('Mountain View', $location->getCity());
}
```
~~~ 
Сохранение в Git:  Внешний вид и тесты
~~~
В примитивном виде, что из себя должен представлять Location?
Это может быть некая структура, содержащая нужные нам поля и которую мы можем заполнить через конструктор.
```php
class Location
{
    private $country;
    private $region;
    private $city;

    public function __construct(
        string $country,
        ?string $region,
        ?string $city) {
        $this->country = $country;
        $this->region = $region;
        $this->city = $city;
    }

    public function getCountry(): string {
        return $this->country;
    }

    public function getRegion(): ?string {
        return $this->region;
    }

    public function getCity(): ?string {
        return $this->city;
    }
}
```

