Лекция "Суть компонентного фреймворка": https://deworker.pro/edu/series/http-framework/definition

1. Что такое фреймворк и что значит слово "компонентный"?
2. Что такое поток управления Control Flow?
3. Для чего используют готовый код?
4. Старый и новый способ организации кода.
5. Что такое запускающий код?
6. Чем фреймворк отличается от библиотеки?
7. Для чего используются компоненты и пакетные менеджеры?
8. Что такое фреймворконезависимые компоненты?
9. Отличия компонентных фреймворков от монолитных.
10. Проблема несовместимости и её решение через использование общих интерфейсов.

Компонентный HTTP-фреймворк

Фреймворк - некий каркас на котором мы можем строить свое приложение.

Control Flow - представим, что у нас есть код, который мы можем запускать из консоли и из http-сервера.
В случае, если мы запускаем код в http-сервере, то обычно мы его помещаем в файл index.php.
NGINX
    Code
        index.php
Если код простой, то мы можем его написать сами, но часто требуется использовать уже готовые чужие фрагменты кода.
Например, код для работы с базой данных, для отправки эл.писем.
NGINX
    Code
        index.php
            DB
            Mailer
Если мы используем чужие компоненты, то у нас получается такой поток управления:
1. Запрос приходит на сервер NGINX
2. Который через PHP-FPM запускает наш файл index.php
3. Потом запускается наш код и этот код вызывает наши компоненты
NGINX
    Code
        index.php
            DB      $db->query('SELECT...');
            Mailer  $mailer->send($message);
В любом сложном веб-приложении, код распределяется по различным файлам: главная страница, блог, магазин.
index.php   blog.php    shop.php
Если мы рассматриваем современный способ разработки, то там договорились, что мы используем всегда один файл
и все запросы будем отправлять на него. Таким образом, наш файл index.php будет анализировать какой запрос
поступил и будет выполнять соответствующие для него действия.
Операции, которые необходимо выполнить определяются на основе адреса, который поступил из веб-сервера.
index.php
    /home         /blog         /shop
    Code1(Home)   Code2(Blog)   Code3(Shop)
В связи с этим встает вопрос о вспомогательном коде, который будет решать какой код нам необходимо
запустить взависимости от поступившего запроса.
HTTP-Server
    \
    Application
      \
       Code
        - DB
        - Mailer
Framework > Code > Library (DB, Mailer)
Если фреймворк работает с веб-сервером, то такой фреймворк называют HTTP-фреймворком, но тот же код можно запускать
и в консольном приложении, например какие-либо очереди. Как правило для этого используется другой файл и
другое приложение.
index.php
HTTPApplication
    \
     Code
worker.php
WorkerApplication
    \
     Code
В HTTP-фреймворке для анализа запроса используют некий Router, но также может использоваться некий Logger
и Cache. Все эти вещи располагаются над нашим кодом и являются фреймворком. Но теже самые библиотеки мы можем
использовать в своем коде.
index.php
HTTPApplication > Router, Logger, Cache
    \
     Code
        - DB
        - Logger
        - Cache
        - Mailer

Компонентами являются те самые пакеты, которые мы можем установить с вами через пакетный менеджер Composer.
----------------------------------------------------------------------
Раньше, до появления пакетных менеджеров ситуация была грустной.
1. На своих сайтах размещали свой код в архиваъ ZIP
2. Появление GitHub и публичных репозиториев, где каждый может вносить свой вклад в разработку и исправление.
3. Чтобы не клонировать и не скачивать эти репозитории в свой проект вручную придумали пакетный менеджер.
Любой может привязать свой публичный репозиторий на сайте packagist.org
-----------------------------------------------------------------------
Теперь, если три программиста написали компоненты: X1, X2, X3.
То четвертый программист может создать библиотеку L1, содержащую в себе например компонетны X1 и X2.
А пятый программист может написать свой собственный фреймворк F1 используя, например библиотеку L1 и компонент X3.
Экономия времени в этом случае получается существенной.

Бывают ситуации, когда один компонет мы можем использовать у себя в проекте, а другой задействовать не получается.
Почему такое может быть?
Это зависит как он был написан. Если компонент самодостаточен, то его можно будет использовать в любом проекте.
Но помимо этого могут быть какие-либо плагины, например для Wordpress, которые без установки самого Wordpress
работать не будут.

Фреймворки можно разделить на компонентные и монолитные.
Монолитные обычно распространяются в виде одной папки, одного репозитория или одного zip-архива.
В них весь код свален в одну кучи и обычно сильно связан друг с другом.
В таких фреймворкам нам часто невозможно использовать часть кода в других проектах.
В компонентных фреймворках сосредотачиваются на написании основного кода приложения, а все остальное
(Router, Logger, Cache ...) подключатся в виде отдельных компонентов.

Все фреймворки до появления Composer делались на монолитной структуре, так как ещё не было общедоступных компонентов.
Каждый фреймворк создавал собственную версию Router, Logger, Cache ..., которые были несовместимы друг с другом.
В результате в каждом компоненте мог быть свой логгер и система кеша, что в приводило к полному бардаку.
Чтобы избежать этого, договорились следовать общим интерфейсам:
LoggerInterface, CacheInterface
Ознакомиться со списком таких общих интерфейсов можно на сайте php-fig.org

Таким образом, если наш код будет следовать PSR-рекомендациям, то он станет переносимым на любой
PSR-совместимый фреймворк.


